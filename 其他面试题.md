>
> **其他面试题：**
>
> **Node的应用场景**
>
> **特点：**
>
> 它是一个javascript运行环境
>
> 依赖chrome V8引擎进行代码解析
>
> 事件驱动
>
> 非阻塞I/O
>
> 单进程、单线程
>
> 优点：高并发（最重要的优点）
>
> 缺点：只支持单核CPU，不能充分利用CPU
>
> 可靠性地，一旦代码某个环节崩溃，整个系统都崩溃
>
> 
>
> **谈谈你对****webpack的看法**
>
> webpack是一个模块打包工具，你可以使用webpack管理你的模块依赖，并编译输出模块们所需要的静态文件。它能够很好地管理、打包web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后生成了优化且合并后的静态资源
>
> **gulp是什么？**
>
> gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成
>
> Gulp的核心概念：流
>
> 流：简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向
>
> gulp正是通过流和代码优于配置的策略来尽量简化任务编写的任务
>
> **Gulp的特点：**
>
**易于使用：**通过代码优于配置的策略，gulp让简单的任务鸡蛋，复杂的任务可管理
>
> **构建快速：**利用nodeJs流的威力，你可以快速构建项目并减少频繁的IO操作
>
**易于学习：**通过最少的API，掌握gulp毫不费力，构建工作仅在掌握：如同一系列流管道
>
**常见的****web安全及防护原理**
>
> sql注入原理：
>
> 就是通过把SQL命令插入到web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令
>
> 总的来说有以下几点：
>
> \- 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双引号以及-进行转换等
>
> \- 永远不要使用动态拼接SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取
>
> \- 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接
>
> \- 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息
>
**XSS原理及防范方法**
>
> xss（cross-site-scripting）攻击指的是攻击者往web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器汇总，而不是用户原本以为的信任站点
>
**防范方法：**首先代码里对用户输入的地方和变量都需要仔细检查长度和对“<> , ; . ”等字进行过滤；其次仁和内容写到页面之前都必须加encode，避免不小心把html tag弄出来。这一个层面做好，至少可以堵住超过一半的XSS攻击
>
**CSRF的原理及防御**
>
> CSRF是代替用户完成指定的动作，需要知道其他哟范湖页面的代码和数据包。要完成一次CSRF攻击，受害者必须一次完成两个步骤
>
> 登录受信任网站A，并在本地生成cookie
>
> 在不登出A的情况下，访问危险网站B
>
**防御方法：**服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数；通过验证码的方法
>
**XSS与CSRF两种跨站攻击**
>
> \1. XSS跨站脚本攻击，主要是前端层面，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转移，不运行js对cookie的读写
>
> \2. CSRF跨站请求伪造，以你的名义，发送恶意请求，通过cookie加参数等形式过滤
>
> \3. 我们没法彻底杜绝攻击，只能提高攻击门槛
>
**common.js  AMD CMD的区别**
>
> \1. 这些规范的目的都是为了js的模块化开发，特别是在浏览器端的
>
> \2. 对于依赖的模块，AMD是提前执行，CMD是延迟执行
>
> \3. CMD推崇依赖就近，AMD推崇依赖前置
>
> **ES6模块有CommonJS模块的差异**
>
> \1. CommonJS模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用
>
> \2. CommonJS模块时运行时加载，ES6模块时编译输出接口
>
> \3. ES6输入的模块变量，知识一个符号链接，所以这个变量是只读的，对它进行重新赋值就会报错
>
> **网页验证码是干嘛的，是为了解决什么安全问题**
>
> · 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水
>
> · 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试
>
> **图片压缩上传****(移动端):**
>
> **为什么要使用图片压缩上传功能****?**
>
> 在做移动端图片上传的收，用户穿的都是手机本地图片，而本地图片一般都相对比较大，拿IPhone6来说，平时拍的图片都是1-2M，如果直接上传，会占用一定的内存以及耗费大量的流量去长传文件，完整把图片上传显然不是一个很好的办法。目前来说HTML5的各种新API都在移动端的webkit是上得到了较好的实现。
>
> **图片压缩上传功能的实现步骤？**
>
> · 在移动端压缩图片并且上传主要用到的是filereader /faɪl/ /'riːdə/ 、canvas以及formdata这三个H5的API。
>
> · 1）用户使用input file上传图片的时候，用filereader读取用户上传的图片数据（base64格式）
>
> · 2）把图片数据传入img对象，然后将img绘制到canvas上，再调用canvas。toDataURL对图片进行压缩
>
> · 3）获取到压缩后的base64格式图片数据，转成二进制塞入formdata，在通过XMLHttpRequest提交到fromdata
>
> · 仅有三步即可完成图片压缩上传功能，但是实现功能比较复杂，代码参考地址：https://www.cnblogs.com/axes/p/4603984.html
>
> 
>**Jquery实现图片懒加载 :**
>
> <script>
>
> // 注意: 需要引入jQuery和underscore
>
> $(function() {
>
> ​     // 获取window的引用:
>
> ​     var $window = $(window);
>
> ​     // 获取包含data-src属性的img，并以jQuery对象存入数组:
>
> ​     var lazyImgs = _.map($('img[data-src]').get(), function (i) {
>
> ​       return $(i);
>
> ​     });
>
> ​     // 定义事件函数:
>
> ​     var onScroll = function() {
>
> ​       // 获取页面滚动的高度:
>
> ​       var wtop = $window.scrollTop();
>
> ​       // 判断是否还有未加载的img:
>
> ​       if (lazyImgs.length > 0) {
>
> ​         // 获取可视区域高度:
>
> ​         var wheight = $window.height();
>
> ​         // 存放待删除的索引:
>
> ​         var loadedIndex = [];
>
> ​         // 循环处理数组的每个img元素:
>
> ​         _.each(lazyImgs, function ($i, index) {
>
> ​           // 判断是否在可视范围内:
>
> ​           if ($i.offset().top - wtop < wheight) {
>
> ​             // 设置src属性:
>
> ​             $i.attr('src', $i.attr('data-src'));
>
> ​             // 添加到待删除数组:
>
> ​             loadedIndex.unshift(index);
>
> ​           }
>
> ​         });
>
> ​         // 删除已处理的对象:
>
> ​         _.each(loadedIndex, function (index) {
>
> ​           lazyImgs.splice(index, 1);
>
> ​         });
>
> ​       }
>
> ​     };
>
> ​     // 绑定事件:
>
> ​     $window.scroll(onScroll);
>
> ​     // 手动触发一次:
>
> ​     onScroll();
>
> </script>
>
> onScroll()函数最后要手动触发一次，因为页面显示时，并未触发scroll事件。如果图片已经在可视化区域内，这些图片仍然是loading状态，需要手动触发一次，就可以正常显示。
>> **如何优化****SPA(单页面Web应用)****应用的首屏加载速度慢的问题？**
>
> 1) 将公用的JS库通过script标签外部引入，减少app。bundel的大小，让浏览器并行下载资源文件，提高下载速度
>
> 2) 在配置路由时，页面和组件使用懒加载的方式引入，进一步缩小App。bundel的体积，在调用某个组件时再加载对应的js文件
>
> 3) 加一个首屏loading图，提升用户体验
>> **移动端常见的兼容性问题****:**
>
> 随着手机的普及,移动端的开发也成了一个重要方向，但是由于设备的不统一，会造成一些兼容性问题。
>
> \1. 设置文字行高为字体行高，解决文字上下边留白问题
>
> \2. 给动态元素添加事件，需要使用事件委托（绑定到document），解绑也需要用委托的方式。苹果机点击事件不能触发。需要用touch系列事件
>
> \3. Img标签src属性无值（php渲染过的），在苹果机上显示无图片，在安卓机上显示图片裂开。可添加alt属性及值
>
> \4. 同一个标签多次绑定同一个事件（页面复杂情况容易出现这种情况，尽量避免这种情况），可以减少bug的出现，利于维护页面
>
> \5. 在rem自适应页面使用精灵图。会容易出现图片缺角的问题（约1-2像素）。解决办法：使装精灵图的盒子变大，让图片居中显示
>
> \6. 给选中的盒子增加一个标识，可以使用伪元素，减少标签的使用
>
> \7. 有横向滚动条的内容被垂直触摸，在IOS机上无法滚动页面
>
> \8. 当祖父元素使用overflow属性时，父元素采用transform属性会影响子元素定位position:absolute；导致子元素超出隐藏，建议用其他属性替换transform属性。
>
> \9. click事件在IOS系统上有时会失效，给绑定click事件的元素加上cursor：pointer解决
>
> \10. placeholder垂直居中问题：在IOS和Android中显示不同。解决方法是：在保证input输入文本垂直居中的条件下，给placehoder设置padding-top
>

